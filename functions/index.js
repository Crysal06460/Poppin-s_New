const {onDocumentCreated} = require('firebase-functions/v2/firestore');
const {onSchedule} = require('firebase-functions/v2/scheduler');
const {initializeApp} = require('firebase-admin/app');
const {getFirestore, FieldValue} = require('firebase-admin/firestore');
const {getMessaging} = require('firebase-admin/messaging');

// ===== IMPORTS POUR LES EMAILS AVEC MAILJET =====
const Mailjet = require('node-mailjet');
const fs = require('fs');
const handlebars = require('handlebars');
const path = require('path');

// Initialiser Firebase Admin
initializeApp();

const db = getFirestore();
const messaging = getMessaging();

// ===== CONFIGURATION MAILJET =====
const mailjet = Mailjet.apiConnect(
  '47ce0aca4cc62f625096a6af3fa5cb8a', // Votre cl√© API Mailjet
  '22096ea903efc5beb1e190890b870f97'  // Votre cl√© secr√®te Mailjet
);

// ===== NOUVELLE FONCTION : Traiter la queue d'emails avec Mailjet =====
exports.processEmailQueue = onDocumentCreated({
    document: 'emailQueue/{emailId}',
    region: 'europe-west1' // M√™me r√©gion que vos autres fonctions
}, async (event) => {
    const emailData = event.data.data();
    const emailId = event.params.emailId;
    
    console.log(`üìß Traitement de l'email ${emailId}:`, JSON.stringify(emailData, null, 2));
    
    try {
        // V√©rifier que le statut est bien 'pending'
        if (emailData.status !== 'pending') {
            console.log(`üìß Email ${emailId} ignor√© - statut: ${emailData.status}`);
            return null;
        }
        
        // V√©rifier si toutes les donn√©es n√©cessaires sont pr√©sentes
        if (!emailData.to || !emailData.templateData) {
            console.error('‚ùå Donn√©es d\'email insuffisantes:', emailData);
            await event.data.ref.update({
                status: 'failed',
                error: 'Donn√©es insuffisantes',
                lastErrorAt: FieldValue.serverTimestamp()
            });
            return null;
        }
        
        // Marquer comme 'processing'
        await event.data.ref.update({
            status: 'processing',
            processingStartedAt: FieldValue.serverTimestamp()
        });
        
        console.log(`üìß D√©but traitement email pour: ${emailData.to}`);
        console.log(`üìß Template demand√©: ${emailData.template}`);
        
        // Charger et compiler le template d'email
        let templatePath = 'templates/parent-invitation.html'; // Template par d√©faut
        if (emailData.template && typeof emailData.template === 'string') {
            const requestedTemplate = `templates/${emailData.template}.html`;
            try {
                // V√©rifier si le fichier existe
                fs.accessSync(path.join(__dirname, requestedTemplate), fs.constants.R_OK);
                templatePath = requestedTemplate;
                console.log(`‚úÖ Utilisation du template: ${templatePath}`);
            } catch (e) {
                console.warn(`‚ö†Ô∏è Template '${requestedTemplate}' non trouv√©, utilisation du template par d√©faut`);
                templatePath = 'templates/parent-invitation.html';
            }
        }

        console.log(`üìÑ Chargement du template: ${templatePath}`);
        const templateSource = fs.readFileSync(path.join(__dirname, templatePath), 'utf8');
        console.log('‚úÖ Template charg√© avec succ√®s');
        
        const compiledTemplate = handlebars.compile(templateSource);
        
        // G√©n√©rer le contenu HTML avec les donn√©es du template
        const htmlContent = compiledTemplate(emailData.templateData);
        console.log('‚úÖ Template compil√© avec succ√®s');
        
        // Pr√©parer le message Mailjet
        const mailjetMessage = {
            From: {
                Email: "noreply@poppin-s.app",
                Name: "Les Lutins - Application Poppins"
            },
            To: [
                {
                    Email: emailData.to
                }
            ],
            Subject: emailData.subject || 'Invitation √† l\'application Poppins',
            HTMLPart: htmlContent
        };
        
        // Ajouter la pi√®ce jointe PDF si elle existe
        if (emailData.pdfAttachment && emailData.pdfFilename) {
            console.log(`üìé Ajout pi√®ce jointe PDF: ${emailData.pdfFilename}`);
            mailjetMessage.Attachments = [
                {
                    ContentType: 'application/pdf',
                    Filename: emailData.pdfFilename,
                    Base64Content: emailData.pdfAttachment
                }
            ];
        }
        
        // Envoyer l'email via Mailjet
        console.log(`üìß Envoi email vers: ${emailData.to} via Mailjet...`);
        
        const request = mailjet.post('send', { version: 'v3.1' }).request({
            Messages: [mailjetMessage]
        });
        
        const result = await request;
        
        console.log(`‚úÖ Email ${emailId} envoy√© avec succ√®s via Mailjet`);
        console.log('üìä R√©ponse Mailjet:', JSON.stringify(result.body, null, 2));
        
        // Marquer comme 'sent'
        await event.data.ref.update({
            status: 'sent',
            sentAt: FieldValue.serverTimestamp(),
            messageId: result.body?.Messages?.[0]?.MessageID || 'unknown',
            mailjetResponse: result.body
        });
        
        console.log(`‚úÖ Email ${emailId} marqu√© comme envoy√© dans Firestore`);
        
    } catch (error) {
        console.error(`‚ùå Erreur lors de l'envoi de l'email ${emailId}:`, error);
        console.error('‚ùå Stack trace:', error.stack);
        console.error('‚ùå D√©tails de l\'erreur:', JSON.stringify(error, null, 2));
        
        // Marquer comme 'failed' et incr√©menter le retry count
        const retryCount = (emailData.retryCount || 0) + 1;
        const maxRetries = 3;
        
        await event.data.ref.update({
            status: retryCount >= maxRetries ? 'failed' : 'pending',
            retryCount: retryCount,
            lastError: error.message,
            lastErrorAt: FieldValue.serverTimestamp(),
            errorStack: error.stack
        });
        
        // Si on a atteint le max de tentatives, log l'erreur finale
        if (retryCount >= maxRetries) {
            console.error(`‚ùå Email ${emailId} d√©finitivement √©chou√© apr√®s ${maxRetries} tentatives`);
        } else {
            console.log(`üîÑ Email ${emailId} remis en queue - tentative ${retryCount}/${maxRetries}`);
        }
    }
    
    return null;
});

// ===== NOUVELLE FONCTION : Retry des emails failed =====
exports.retryFailedEmails = onSchedule({
    schedule: 'every 2 hours',
    region: 'europe-west1'
}, async (event) => {
    try {
        const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
        
        console.log('üîÑ Recherche des emails √©chou√©s √† retry...');
        
        const failedEmails = await db
            .collection('emailQueue')
            .where('status', '==', 'failed')
            .where('lastErrorAt', '<', twoHoursAgo)
            .where('retryCount', '<', 3)
            .limit(10)
            .get();
        
        if (failedEmails.empty) {
            console.log('‚úÖ Aucun email √©chou√© √† retry');
            return null;
        }
        
        const batch = db.batch();
        
        failedEmails.docs.forEach(doc => {
            console.log(`üîÑ Remise en queue de l'email: ${doc.id}`);
            batch.update(doc.ref, {
                status: 'pending',
                retryCount: 0,
                lastError: null,
                lastErrorAt: null,
                errorStack: null
            });
        });
        
        await batch.commit();
        console.log(`‚úÖ ${failedEmails.size} emails remis en queue pour retry`);
        
    } catch (error) {
        console.error('‚ùå Erreur lors du retry des emails:', error);
    }
    
    return null;
});

// ==========================================
// ===== VOS FONCTIONS EXISTANTES INTACTES =====
// ==========================================

// Fonction pour envoyer des notifications push
exports.sendNotification = onDocumentCreated('notifications/{notificationId}', async (event) => {
    try {
        const notification = event.data.data();
        console.log('üì§ Nouvelle notification √† envoyer:', notification);

        // V√©rifier si la notification a d√©j√† √©t√© envoy√©e
        if (notification.sent) {
            console.log('‚ö†Ô∏è Notification d√©j√† envoy√©e');
            return;
        }

        const recipientUserId = notification.recipientUserId;
        console.log('üéØ Recherche utilisateur:', recipientUserId);
        
        // CORRECTION: Rechercher directement par email (ID du document)
        const userDoc = await db
            .collection('users')
            .doc(recipientUserId)
            .get();

        if (!userDoc.exists) {
            console.log('‚ùå Utilisateur non trouv√©:', recipientUserId);
            // Marquer comme √©chou√©
            await event.data.ref.update({
                sent: false,
                error: 'Utilisateur non trouv√©',
                errorAt: FieldValue.serverTimestamp(),
            });
            return;
        }

        const userData = userDoc.data();
        const fcmToken = userData.fcmToken;

        if (!fcmToken) {
            console.log('‚ùå Token FCM non trouv√© pour:', recipientUserId);
            // Marquer comme √©chou√©
            await event.data.ref.update({
                sent: false,
                error: 'Token FCM non trouv√©',
                errorAt: FieldValue.serverTimestamp(),
            });
            return;
        }

        console.log('üéØ Token FCM trouv√©:', fcmToken.substring(0, 20) + '...');

        // Pr√©parer le message
        const message = {
            notification: {
                title: notification.title,
                body: notification.body,
            },
            data: {
                ...notification.data,
                click_action: 'FLUTTER_NOTIFICATION_CLICK',
            },
            token: fcmToken,
            apns: {
                payload: {
                    aps: {
                        badge: 1,
                        sound: 'default',
                        'content-available': 1,
                    },
                },
            },
            android: {
                priority: 'high',
                notification: {
                    channel_id: 'messages_channel',
                    priority: 'high',
                    visibility: 'public',
                },
            },
        };

        // Envoyer la notification
        const response = await messaging.send(message);
        console.log('‚úÖ Notification envoy√©e avec succ√®s:', response);

        // Marquer la notification comme envoy√©e
        await event.data.ref.update({
            sent: true,
            sentAt: FieldValue.serverTimestamp(),
            messageId: response,
        });

    } catch (error) {
        console.error('‚ùå Erreur lors de l\'envoi de la notification:', error);
        
        // Marquer la notification comme √©chou√©e
        await event.data.ref.update({
            sent: false,
            error: error.message,
            errorAt: FieldValue.serverTimestamp(),
        });
    }
});

// üî• FONCTION PRINCIPALE CORRIG√âE : G√©rer TOUS les messages (avec ou sans parentId)
exports.onNewMessage = onDocumentCreated('exchanges/{messageId}', async (event) => {
    console.log('üî• DEBUT onNewMessage - Message d√©tect√© !');
    
    try {
        const messageData = event.data.data();
        console.log('üìã Message data:', JSON.stringify(messageData, null, 2));

        const { childId, senderType, content } = messageData;

        // Skip si d√©j√† trait√©
        if (messageData.notificationSent) {
            console.log('‚ö†Ô∏è Notification d√©j√† trait√©e');
            return;
        }

        let recipientEmail = null;
        let title = '';

        if (senderType === 'parent') {
            // üü¢ MESSAGE PARENT ‚Üí ASSISTANTE (√ßa marche d√©j√†)
            console.log('üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Message du parent vers assistante');
            title = 'Nouveau message d\'un parent';
            recipientEmail = await getAssistantEmail(childId);
            
        } else if (senderType === 'assistante') {
            // üî¥ MESSAGE ASSISTANTE ‚Üí PARENT (√† corriger)
            console.log('üë©‚Äç‚öïÔ∏è Message de l\'assistante vers parent');
            title = 'Nouveau message de Poppin\'s';
            
            // üî• CORRECTION : Ne pas utiliser parentId du message, le chercher dynamiquement
            console.log('üîç Recherche parent pour childId:', childId);
            
            // Chercher directement les parents qui ont cet enfant
            const parentQuery = await db
                .collection('users')
                .where('children', 'array-contains', childId)
                .get();

            console.log('üë™ Nombre de parents trouv√©s:', parentQuery.size);

            if (!parentQuery.empty) {
                recipientEmail = parentQuery.docs[0].id; // ID = email
                console.log('üìß Email parent trouv√©:', recipientEmail);
            } else {
                console.log('‚ùå Aucun parent trouv√© pour childId:', childId);
                
                // FALLBACK : Chercher dans les documents enfants pour r√©cup√©rer parentId
                const structuresSnapshot = await db.collection('structures').get();
                
                for (const structureDoc of structuresSnapshot.docs) {
                    const childDoc = await db
                        .collection('structures')
                        .doc(structureDoc.id)
                        .collection('children')
                        .doc(childId)
                        .get();

                    if (childDoc.exists) {
                        const childData = childDoc.data();
                        const parentId = childData.parentId;
                        
                        if (parentId && parentId.includes('@')) {
                            recipientEmail = parentId.toLowerCase();
                            console.log('üìß Email parent trouv√© via document enfant:', recipientEmail);
                            break;
                        }
                    }
                }
            }
        }

        if (recipientEmail) {
            console.log('‚úÖ Destinataire trouv√©:', recipientEmail);
            
            // Cr√©er la notification
            const notificationData = {
                recipientUserId: recipientEmail,
                title: title,
                body: content || 'Nouveau message',
                data: {
                    childId: childId,
                    messageId: event.params.messageId,
                    type: 'message'
                },
                timestamp: FieldValue.serverTimestamp(),
                sent: false,
                platform: 'ios'
            };

            console.log('üì¨ Cr√©ation notification:', JSON.stringify(notificationData, null, 2));

            await db.collection('notifications').add(notificationData);

            // Marquer le message comme trait√©
            await event.data.ref.update({
                notificationSent: true
            });

            console.log('‚úÖ Notification cr√©√©e avec succ√®s pour:', recipientEmail);
        } else {
            console.log('‚ùå AUCUN destinataire trouv√© !');
            console.log('üìã Debug info:', {
                senderType: senderType,
                childId: childId,
                parentId: messageData.parentId
            });
        }

    } catch (error) {
        console.error('‚ùå Erreur dans onNewMessage:', error);
    }
});

// üî• FONCTION HELPER : Trouver l'email de l'assistante
async function getAssistantEmail(childId) {
    try {
        console.log('üîç Recherche assistante pour enfant:', childId);
        
        // Chercher dans toutes les structures
        const structuresSnapshot = await db.collection('structures').get();

        for (const structureDoc of structuresSnapshot.docs) {
            const childDoc = await db
                .collection('structures')
                .doc(structureDoc.id)
                .collection('children')
                .doc(childId)
                .get();

            if (childDoc.exists) {
                const childData = childDoc.data();
                const assignedMemberEmail = childData.assignedMemberEmail;

                // Si assign√© √† un membre MAM
                if (assignedMemberEmail) {
                    console.log('üìß Membre MAM assign√© trouv√©:', assignedMemberEmail);
                    return assignedMemberEmail.toLowerCase();
                } else {
                    // Sinon, propri√©taire de la structure
                    const structureData = structureDoc.data();
                    const ownerEmail = structureData.ownerEmail;
                    
                    if (ownerEmail) {
                        console.log('üìß Propri√©taire structure trouv√©:', ownerEmail);
                        return ownerEmail.toLowerCase();
                    }
                }
            }
        }

        console.log('‚ùå Aucune assistante trouv√©e pour childId:', childId);
        return null;
    } catch (error) {
        console.error('‚ùå Erreur recherche assistante:', error);
        return null;
    }
}

// Fonction pour nettoyer les anciennes notifications
exports.cleanupOldNotifications = onSchedule('every 24 hours', async (event) => {
    const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 jours
    
    const snapshot = await db
        .collection('notifications')
        .where('timestamp', '<', cutoff)
        .get();

    const batch = db.batch();
    snapshot.docs.forEach(doc => batch.delete(doc.ref));
    
    await batch.commit();
    console.log(`üóëÔ∏è ${snapshot.size} anciennes notifications supprim√©es`);
});